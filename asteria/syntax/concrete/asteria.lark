_WS: /[\r\n\t ]+/
%ignore _WS
_sepby{x, sep}: x (sep x)*
_sepby0{x, sep}: [x (sep x)*]

////////////////  Keywords and Symbols  ////////////////

_WHERE:        "where"
_MODULE:       "module"
_IMPORTING:    "importing"
_UNQUALIFIED:  "unqualified"
_AS:           "as"
_USING:        "using"
_HIDING:       "hiding"
_RENAMING:     "renaming"
_TO:           "to"
_DATA:         "data"
_TYPE:         "type"
_CLASS:        "class"
_INSTANCE:     "instance"
_CASE:         "case"
_OF:           "of"
_LET:          "let"
_IN:           "in"
_FORALL:       "forall"
_TYPEKIND:     "Type"
INFIX:         "infix"
INFIXL:        "infixl"
INFIXR:        "infixr"

_EQ:         "="
_BIG_ARROW:  "=>"
_COLON:      ":"
_ARROW:      "->"
_LAMBDA:     "\\"
_AT:         "@"
_DOT:        "."
_COMMA:      ","
_PIPE:       "|"
_LPAR:       "("
_RPAR:       ")"
_LBRACE:     "{"
_RBRACE:     "}"
_LBRACK:     "["
_RBRACK:     "]"
_DOUBLESEMI: ";;"






////////////////  Names and Operators  ////////////////

VARNAME: /(?!(_|where|module|import|unqualified|as|using|hiding|to|data|type|class|instance|case|of|let|in|forall)\b)[a-z_][a-zA-Z0-9_]*/
CONNAME: /(?!(Type)\b)[A-Z][a-zA-Z0-9_]*/
//OPERATOR: /(?!(=|=>|:|->|\\|@|\.|,|\||;;)\b)[~!@#$%^&*\\\-|+=:;<>?\/\.]+/
OPERATOR: /(=>|:|->|@|,|\||;;)[~!@#$%^&*\-|+=:;<>?\/\.]+/
        | /=[~!@#$%^&*\-|+=:;<?\/\.][~!@#$%^&*\-|+=:;<>?\/\.]*/
        | /-([~!@#$%^&*\|+=:;<?\/\.][~!@#$%^&*\-|+=:;<>?\/\.]*)?/
        | /;([~!@#$%^&*\-|+=:<>?\/\.][~!@#$%^&*\-|+=:;<>?\/\.]*)?/
        | /[~!#$%^&*+<>?\/\.][~!@#$%^&*\-|+=:;<>?\/\.]*/
_name: VARNAME | CONNAME | _LPAR OPERATOR _RPAR
_termname: VARNAME | _LPAR OPERATOR _RPAR





////////////////  Modules  ////////////////


module: _MODULE CONNAME imports _WHERE declarations _DOUBLESEMI?

imports: [_IMPORTING import+]

import: _PIPE import_sort import_renaming

?import_sort: qualified_import
            | unqualified_import
            | as_import

qualified_import: CONNAME
unqualified_import: CONNAME _UNQUALIFIED using_hiding
as_import: CONNAME _AS CONNAME

using_hiding: (import_using | import_hiding)?

import_using: _USING _LPAR _sepby{_name, _COMMA} _RPAR
import_hiding: _HIDING _LPAR _sepby{_name, _COMMA} _RPAR

import_renaming: (_RENAMING _LPAR renaming_clause (_COMMA renaming_clause)* _RPAR)?

?renaming_clause: termname_renaming
                | conname_renaming

termname_renaming: _termname _TO _termname
conname_renaming: CONNAME _TO CONNAME






////////////////  Declarations  ////////////////

declarations: declaration*

// Declaration Decl
//   ::=  data Cn TVK* where ConDecl*             (Data Declaration)
//     |  type f TVK* = A                         (Type Synonym Declaration)
//     |  class CCn TVK* <= (CC*) where MetDecl*  (Type Class Declaration)
//     |  x : A                                   (Term Type Signature)
//     |  x Pat* | M? = N                         (Term Equation)
//     |  instance CCn A+ <= (CC*) where MetEq*   (Instance Declaration)

?declaration: fixity_declaration
            | data_declaration
            | type_synonym_declaration
            | type_class_declaration
            | type_signature
            | term_equation
            | instance_declaration

tyvarkindings: tyvarkinding*
mandatory_tyvarkindings: tyvarkinding+
tyvarkinding: _LPAR tyvarnames _COLON kind _RPAR
tyvarnames: VARNAME+

implicit_tyvarkindings: implicit_tyvarkinding*
implicit_tyvarkinding: _LBRACE tyvarnames _COLON kind _RBRACE

vartypings: vartyping*
vartyping: _LPAR varnames _COLON type _RPAR
varnames: VARNAME+






////////////////  Fixity Declarations  ////////////////

fixity_declaration: _fixity _fixity_level operators

_fixity: INFIX
       | INFIXL
       | INFIXR

_fixity_level: /0|[1-9][0-9]*/

operators: OPERATOR+

////////////////  Data Declarations  ////////////////

data_declaration: _DATA CONNAME tyvarkindings _WHERE data_body _DOUBLESEMI


// ConstructorDecl ConDecl ::=  Cn TVK* VT* : A  (Constructor Declaration)

data_body: constructor_declaration*

constructor_declaration: _PIPE CONNAME implicit_tyvarkindings vartypings _COLON type






//////////////// Type Synonym Declarations  ////////////////

type_synonym_declaration: _TYPE VARNAME tyvarkindings _EQ type _DOUBLESEMI






//////////////// Type Class Declarations  ////////////////

type_class_declaration: _CLASS class_quantification class_precondition CONNAME class_params _WHERE class_body _DOUBLESEMI

class_quantification: (_FORALL mandatory_tyvarkindings _DOT)

class_precondition: (_LPAR _sepby{class_constraint,_COMMA} _RPAR _BIG_ARROW)?

class_params: VARNAME*

class_body: method_declaration*

// MethodDeclaration MetDecl ::=  x : A  (Method Declaration)
method_declaration: _PIPE VARNAME _COLON type





////////////////  Type Signature  ////////////////

type_signature: VARNAME _COLON type _DOUBLESEMI






////////////////  Term Equation  ////////////////

term_equation: VARNAME equation_arg_patterns guard _EQ term _DOUBLESEMI

guard: [_PIPE term]






////////////////  Instance Declaration  ////////////////

instance_declaration: _INSTANCE class_quantification class_precondition CONNAME type* _WHERE instance_body _DOUBLESEMI

instance_body: method_equation*

// MethodEquation MetEq ::=  x Pat* = N  (Method Equation)
method_equation: _PIPE VARNAME equation_arg_patterns guard _EQ term






////////////////  Kinds  ////////////////

?kind: type_kind
     | arrow_kind
     | paren_kind

type_kind: _TYPEKIND

arrow_kind: _arrow_kind_left _ARROW kind
_arrow_kind_left: type_kind
                | paren_kind

?paren_kind: _LPAR kind _RPAR






////////////////  Types  ////////////////

// Type A, B ::=  a              (Type Variable)
//             |  Cn             (Type Name)
//             |  A -> B         (Function Type)
//             |  CC => A        (Constrained Type)
//             |  forall TVK. B  (Forall Type)
//             |  A B            (Type Application)

?type: type_variable
     | type_name
     | function_type
     | constrained_type
     | forall_type
     | type_application
     | paren_type

type_variable: VARNAME

type_name: CONNAME

function_type: _function_type_left _ARROW type
_function_type_left: type_variable
                   | type_name
                   | type_application
                   | paren_type

constrained_type: _LPAR _sepby{class_constraint,_COMMA} _RPAR _BIG_ARROW type

forall_type: _FORALL mandatory_tyvarkindings _DOT type

type_application: _type_application_left _type_application_right
_type_application_left: type_variable
                      | type_name
                      | type_application
                      | paren_type
_type_application_right: type_variable
                       | type_name
                       | paren_type

paren_type: _LPAR type _RPAR






//////////////// Class Constraints ////////////////

class_constraint: CONNAME constraint_args

constraint_args: type*






////////////////  Patterns  ////////////////

?pattern: variable_pattern
        | constructor_pattern
        | paren_pattern

variable_pattern: VARNAME

constructor_pattern: CONNAME argument_patterns

paren_pattern: _LPAR pattern _RPAR

argument_patterns: argument_pattern*

?argument_pattern: variable_pattern
                 | no_arg_constructor_pattern -> pattern
                 | paren_pattern

no_arg_constructor_pattern: CONNAME

equation_arg_patterns: equation_arg_pattern*

?equation_arg_pattern: argument_pattern
                     | type_variable_binding

type_variable_binding: _LBRACE VARNAME _RBRACE






////////////////  Terms  ////////////////

// Term M, N ::=  M : A               (Type Annotation)
//             |  x                   (Variable)
//             |  Cn                  (Constructor)
//             |  \x -> M             (Lambda Abstraction)
//             |  M N                 (Function Application)
//             |  \{a} -> M           (Type Abstraction)
//             |  M {A}               (Type Instantiation)
//             |  case M* of Cls*     (Case)
//             |  let LDecl+ in M     (Let)
//             |  M op N              (Infix Expression)
//             |  (op)                (Infix Operator)

?term: type_annotation
     | variable
     | constructor
     | lambda
     | application
     | case
     | let
     | infix
     | infix_operator
     | slice
     | paren_term

type_annotation: _annotation_left _COLON type
_annotation_left: variable
                | constructor
                | application
                | infix_operator
                | slice
                | paren_term

variable: VARNAME

constructor: CONNAME

lambda: _LAMBDA formal_parameters _ARROW term

formal_parameters: formal_parameter+

?formal_parameter: variable_parameter
                 | vartyping
                 | type_variable_parameter
                 | implicit_tyvarkinding

variable_parameter: VARNAME

type_variable_parameter: _LBRACE VARNAME _RBRACE

application: _application_left _application_right
_application_left: variable
                 | constructor
                 | application
                 | infix_operator
                 | slice
                 | paren_term
_application_right: variable
                  | constructor
                  | infix_operator
                  | slice
                  | paren_term
                  | type_instantiation

type_instantiation: _LBRACE type _RBRACE

case: _CASE _case_scrutinee _OF case_body
_case_scrutinee: variable
               | constructor
               | application
               | infix
               | infix_operator
               | slice
               | paren_term

case_body: case_clause*

// CaseClause Cls ::=  Pat | M -> N  (Case Clause)
case_clause: _PIPE pattern guard _ARROW term

let: _LET let_declarations _IN term

let_declarations: let_declaration (_PIPE let_declaration)*

// LetDec LDecl ::=  x : A             (Let Type Signature)
//                |  x Pat* `|` M = N  (Let Term Equation)
?let_declaration: let_type_signature
                | let_term_equation

let_type_signature: VARNAME _COLON type
let_term_equation: VARNAME equation_arg_patterns guard _EQ term

infix: term OPERATOR _infix_right
_infix_right: variable
            | constructor
            | application
            | infix_operator
            | slice
            | paren_term

infix_operator: _LPAR OPERATOR _RPAR

?slice: left_slice
      | right_slice

left_slice: _LPAR term OPERATOR _RPAR

right_slice: _LPAR OPERATOR _infix_right _RPAR

paren_term: _LPAR term _RPAR
