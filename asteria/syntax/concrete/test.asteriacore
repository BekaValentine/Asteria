-- module where

-- data Nat where
--    | Zero : Nat
--    | Suc (n : Nat) : Nat
--    ;;
data Data.Nat$Nat where
   | Data.Nat$Nat$Zero : Data.Nat$Nat()
   | Data.Nat$Nat$Suc (n : Data.Nat$Nat()) : Data.Nat$Nat()
   ;;

-- (+) : Nat -> Nat -> Nat;;
-- Zero + n = n;;
-- Suc m + n = Suc (m + n);;
Data.Nat$+ : Data.Nat$Nat() -> Data.Nat$Nat() -> Data.Nat$Nat() = \m -> \n ->
  case m of
    | Data.Nat$Nat$Zero(;) -> n
    | Data.Nat$Nat$Suc(;m) -> Data.Nat$Nat$Suc(; Data.Nat$+ m n)
    ;;

--------------------------------------------------------------------------------

-- module where

-- data Maybe (a : Type) where
--    | Nothing      : Maybe a
--    | Just (x : a) : Maybe a
--    ;;
data Data.Maybe$Maybe (a : Type) where
   | Data.Maybe$Maybe$Nothing {a : Type} : Data.Maybe$Maybe(a)
   | Data.Maybe$Maybe$Just {a : Type} (x : a) : Data.Maybe$Maybe(a)
   ;;

--------------------------------------------------------------------------------

-- module
-- importing
--   | Data.Nat unqualified
--   | Data.Maybe unqualified
-- where

-- data List (a : Type) where
--    | Nil                        : List a
--    | Cons (x : a) (xs : List a) : List a
--    ;;
data Data.List$List (a : Type) where
  | Data.List$List$Nil {a : Type} : Data.List$List(a)
  | Data.List$List$Cons {a : Type} (x : a) (xs : Data.List$List(a)) : Data.List$List(a)
  ;;

-- map : forall (a b : Type). (a -> b) -> List a -> List b;;
-- map _ Nil = Nil;;
-- map f (Cons x xs) = Cons (f x) (map f xs);;
Data.List$map : forall (a : Type). forall (b : Type). (a -> b) -> Data.List$List(a) -> Data.List$List(b)
  = \{a} -> \{b} -> \f -> \xs ->
  case xs of
    | Data.List$List$Nil(;) -> Data.List$List$Nil(;)
    | Data.List$List$Cons(; x, xs) -> Data.List$List$Cons(; f x, Data.List$map {a} {b} f xs)
    ;;

-- lookup : forall (a : Type). Nat -> List a -> Maybe a;;
-- lookup Zero    (Cons x _)  = Just x;;
-- lookup (Suc i) (Cons _ xs) = lookup i xs;;
-- lookup _       _           = Nothing;;
Data.List$lookup : forall (a : Type). Data.Nat$Nat() -> Data.List$List(a) -> Data.Maybe$Maybe(a)
  = \{a} -> \i -> \xs ->
  case i | xs of
    | Data.Nat$Nat$Zero(;) | Data.List$List$Cons(; x, _) -> Data.Maybe$Maybe$Just(;x)
    | Data.Nat$Nat$Suc(;n) | Data.List$List$Cons(; _, xs) -> Data.List$lookup n xs
    | _ | _ -> Data.Maybe$Maybe$Nothing(;)
    ;;

--------------------------------------------------------------------------------

-- module where
-- data Unit where Triv : Unit;;
data Data.Unit$Unit where
  | Data.Unit$Unit$Triv : Data.Unit$Unit()
  ;;

-- module Data.Prod where
-- data Prod (a b : Type) where Pair (x : a) (y : b) : Prod a b;;
data Data.Prod$Prod (a : Type) (b : Type) where
  | Data.Prod$Prod$Pair {a : Type} {b : Type} (x : a) (y : b) : Data.Prod$Prod(a,b)
  ;;

-- module
-- importing
--   | Data.Unit unqualified
--   | Data.Prod unqualified
-- where
-- data LC (a : Type) where
--    | LCTriv                                          : LC Unit
--    | LCPair {a b : Type} (x : LC a) (y : LC b)       : LC (Prod a b)
--    | LCFst {a b : Type} (p : LC (Prod a b))          : LC a
--    | LCSnd {a b : Type} (p : LC (Prod a b))          : LC b
--    | LCLam {a b : Type} (f : LC a -> LC b)           : LC (a -> b)
--    | LCApp {a b : Type} (f : LC (a -> b)) (x : LC a) : LC b
--    ;;
data Data.LC$LC (a : Type) where
  | Data.LC$LC$LCTriv : Data.LC$LC(Data.Unit$Unit())
  | Data.LC$LC$LCPair {a : Type} {b : Type} (x : Data.LC$LC(a)) (y : Data.LC$LC(b)) : Data.LC$LC(Data.Prod$Prod(a,b))
  | Data.LC$LC$LCFst {a : Type} {b : Type} (p : Data.LC$LC(Data.Prod$Prod(a,b))) : Data.LC$LC(a)
  | Data.LC$LC$LCSnd {a : Type} {b : Type} (p : Data.LC$LC(Data.Prod$Prod(a,b))) : Data.LC$LC(b)
  | Data.LC$LC$LCLam {a : Type} {b : Type} (f : Data.LC$LC(a) -> Data.LC$LC(b)) : Data.LC$LC(a -> b)
  | Data.LC$LC$LCApp {a : Type} {b : Type} (f : Data.LC$LC(a -> b)) (x : Data.LC$LC(a)) : Data.LC$LC(b)
  ;;